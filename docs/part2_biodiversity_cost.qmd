---
title: 'Part2: biodiversity cost'
author: "Lei Song"
date: "1/4/2023"
toc: true
toc-depth: 2
number-sections: false
toc-location: left
output: 
  html:
      theme: journal
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

# Load libraries
library(here)
library(sf)
library(dplyr)
library(terra)
library(stringr)
library(purrr)
library(parallel)
select <- dplyr::select

# Define paths
data_dir <- here("data")
bio_data_dir <- here("data/biodiversity")
rlt_dir <- here("results")
trdeoff_dir <- here("data/tradeoff")
```

## Introduction

According to previous studies, conservation prioritization analysis should justify all aspects of their biodiversity metrics because modest changes may have significant effects on the result. So we adapted the multifaceted composite biodiversity index (Soto-Navarro et al., 2020) in this study. Additionally, to ensure the reliability, we selected species range maps from multi-sources to get the best quality, and refined the range maps based on the method proposed by Brooks et al. (2019).

Considering the different characteristics of plant and animals, we analyzed the biodiversity cost of plants and animals separately.

-   Major and local plants
-   Animals: mammals, birds, amphibians, and reptiles

The used Biodiversity indices (or products) to describe biodiversity are:

-   Species richness
-   Species endemism (Rarity-weighted richness)
-   Small-ranged species richness
-   Threatened species richness
-   [GLOBIO Mean Species Abundance (MSA, 2015)](https://www.globio.info/globio-data-downloads)
-   [PREDICTS Biodiversity Intactness Index (BII, 2016)](https://data.nhm.ac.uk/dataset/global-map-of-the-biodiversity-intactness-index-from-newbold-et-al-2016-science)
-   [CSIRO Biodiversity Habitat Index (BHI)](https://data.csiro.au/collection/csiro:54237)

The first three indices were calculated with species range maps. Other indices were downloaded from official data sharing websites. Because biodiversity cost in this study is considered as an additional analysis of agriculture-elephant conflict, we gave greater weight to habitat suitability and connectivity of elephants.

## Species level

### Clean and subset the species for Tanzania

In this section, all relevant species (plants and animals) with Tanzania are selected for the analysis. One step prior to this is to select ranges where species were considered "extant", "native" or "reintroduced", and "resident", "breeding", or "non-breeding".

```{r}
# Define path
species_dir <- file.path(bio_data_dir, "range_maps")
if (!dir.exists(species_dir)) dir.create(species_dir)

# Read mainland Tanzania boundary
bry <- read_sf(here("data/geoms/mainland_tanzania.geojson")) %>% 
    select()

# Mammals
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
## Get mammals exist in Tanzania
sf_use_s2(FALSE)
mammals <- read_sf(
    file.path(bio_data_dir, "MAMMALS_TERRESTRIAL_ONLY", 
              "MAMMALS_TERRESTRIAL_ONLY.shp")) %>% 
    st_make_valid()

## Subset extant only for now
## presence: extant (1), probably extant (2 or 3)
## origin: native (1) and reintroduced (2), and Assisted Colonisation (6)
## season: resident (1), breeding season (2) and non-breeding season (3)
## category: exclude EW and EX
mammals <- mammals %>% 
    filter(marine == "false") %>% 
    filter(presence %in% 1:2) %>% 
    filter(origin %in% c(1:2, 6)) %>% 
    filter(seasonal %in% 1:3) %>% 
    filter(!category %in% c("EW", "EX"))

# Check the data
unique(mammals$marine)
unique(mammals$presence)
unique(mammals$origin)
unique(mammals$seasonal)
unique(mammals$category)

# No issues, then subset useful information only
mammals <- mammals %>% 
    select(sci_name, category)

# Get mammals for tanzania
mammals_tz <- mammals %>% 
    slice(unique(unlist(st_intersects(bry, .))))

# Save out
write_sf(mammals, here(species_dir, "mammals_global.geojson"))
write_sf(mammals_tz, here(species_dir, "mammals_tz.geojson"))

# Amphibians
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
amphibians <- read_sf(
    file.path(bio_data_dir, "AMPHIBIANS", "AMPHIBIANS.shp")) %>% 
    st_make_valid()

## Subset extant only for now
## presence: extant (1), probably extant (2 or 3)
## origin: native (1) and reintroduced (2), and Assisted Colonisation (6)
## season: resident (1), breeding season (2) and non-breeding season (3)
## category: exclude EW and EX
amphibians <- amphibians %>% 
    filter(marine == "false") %>% 
    filter(presence %in% 1:2) %>% 
    filter(origin %in% c(1:2, 6)) %>% 
    filter(seasonal %in% 1:3) %>% 
    filter(!category %in% c("EW", "EX"))

# Check the data
unique(amphibians$marine)
unique(amphibians$presence)
unique(amphibians$origin)
unique(amphibians$seasonal)
unique(amphibians$category)

# No issues, then subset useful information only
amphibians <- amphibians %>% 
    select(sci_name, category)

# Get amphibians for tanzania
amphibians_tz <- amphibians %>% 
    slice(unique(unlist(st_intersects(bry, .))))

# Save out
write_sf(amphibians, here(species_dir, "amphibians_global.geojson"))
write_sf(amphibians_tz, here(species_dir, "amphibians_tz.geojson"))

# Birds
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
birds <- read_sf(
    file.path(bio_data_dir, "BOTW.gdb"), layer = "All_Species") %>% 
    left_join(read_sf(
        file.path(bio_data_dir, "BOTW.gdb"), 
        layer = "Taxonomic_checklist"),
        by = c("sisid" = "SISID")) %>% 
    rename(category = RL_Category)

## Subset extant only for now
## presence: extant (1), probably extant (2 or 3)
## origin: native (1) and reintroduced (2), and Assisted Colonisation (6)
## season: resident (1), breeding season (2) and non-breeding season (3)
## category: exclude EW and EX
birds <- birds %>% 
    filter(presence %in% 1:2) %>% 
    filter(origin %in% c(1:2, 6)) %>% 
    filter(seasonal %in% 1:3) %>%
    filter(!category %in% c("EW", "EX"))

# Check the data
unique(birds$presence)
unique(birds$origin)
unique(birds$seasonal)
unique(birds$category)
any(is.na(birds$category))

# No issues, then subset useful information only
birds <- birds %>% 
    select(sci_name, seasonal, category) %>% 
    st_cast("MULTIPOLYGON") %>% 
    rename(geometry = Shape)

# Get birds for tanzania
birds_tz <- birds %>% 
    slice(unique(unlist(st_intersects(bry, .))))

write_sf(birds, here(species_dir, "birds_global.geojson"))
write_sf(birds_tz, here(species_dir, "birds_tz.geojson"))

# Reptiles
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
reptiles <- read_sf(
    file.path(bio_data_dir, "GARD", "Gard_1_7_ranges.shp")) %>% 
    rename(sci_name = binomial) %>% select(sci_name)

# Reptiles from IUCN Red List
reptiles_iucn <- read_sf(
    file.path(bio_data_dir, "REPTILES", "REPTILES_PART1.shp")) %>% 
    select(-OBJECTID) %>% 
    rbind(read_sf(
    file.path(bio_data_dir, "REPTILES", "REPTILES_PART2.shp"))) %>% 
    st_make_valid()

## Subset extant only for now
## presence: extant (1), probably extant (2 or 3)
## origin: native (1) and reintroduced (2), and Assisted Colonisation (6)
## season: resident (1), breeding season (2) and non-breeding season (3)
## category: exclude EW and EX
reptiles_iucn <- reptiles_iucn %>% 
    filter(marine == "false") %>% 
    filter(presence %in% 1:2) %>% 
    filter(origin %in% c(1:2, 6)) %>% 
    filter(seasonal %in% 1:3) %>%
    filter(!category %in% c("EW", "EX"))

# Check the data
unique(reptiles_iucn$presence)
unique(reptiles_iucn$origin)
unique(reptiles_iucn$seasonal)
unique(reptiles_iucn$category)
any(is.na(reptiles_iucn$category))

# Merge the IUCN Red List categories
reptiles <- left_join(
    reptiles, reptiles_iucn %>% 
        select(sci_name, category) %>% 
        st_drop_geometry() %>% unique(),
    by = "sci_name")

# Check the data
unique(reptiles$category)
# has NA, but it does not matter for global
any(is.na(reptiles$category))

# No issues, then subset useful information only
reptiles_iucn <- reptiles_iucn %>% 
    select(sci_name, category)

reptiles <- reptiles %>% 
    select(sci_name, category)

# Get reptiles for tanzania
reptiles_tz <- reptiles %>% 
    slice(unique(unlist(st_intersects(bry, .)))) %>% 
    mutate(id = 1:nrow(.))

write_sf(reptiles_iucn, here(species_dir, "reptiles_global_iucn.geojson"))
write_sf(reptiles, here(species_dir, "reptiles_global.geojson"))
write_sf(reptiles_tz, here(species_dir, "reptiles_tz.geojson"))
```

INFO: These range maps are perfect to use now.

### Refine geographic range map of species

We used the following items to refine the range maps:

-   Preferred habitat types
-   Within the bounds of the altitudinal limits of the species' distribution

#### IUCN Red List assessment

Query these info using from IUCN Red List website. Preferably, the users can use IUCN Red List API to request these information. However, it takes forever for me to request the token, thus we parsed the assessments from the pdf report in a dirty way.

```{r}
# options(java.parameters = "-Xmx16g")
source(here("scripts/query_habitat_elevation_redlist.R"))

assessments <- read.csv(
    file.path(bio_data_dir, "assessments.csv"),
    stringsAsFactors = FALSE) %>% 
    select(assessmentId, internalTaxonId, scientificName)

# Mammals
mammals_nm <- mammals %>% st_drop_geometry() %>% 
    select(sci_name, category) %>% 
    left_join(assessments, by = c("sci_name" = "scientificName")) %>% 
    select(assessmentId, internalTaxonId, sci_name, category) %>% 
    unique()

mammals_info <- lapply(1:nrow(mammals_nm), function(n){
    message(sprintf("No.%s: %s", n, mammals_nm[n, "sci_name"]))
    parse_habitat_elevation(
        mammals_nm[n, ], bio_data_dir, "mammal")
})
save(mammals_info, file = file.path(bio_data_dir, "mammals_info.rda"))

# Amphibians
# INFO: no issue.
amphibians_nm <- amphibians %>% st_drop_geometry() %>% 
    select(sci_name, category) %>% 
    left_join(assessments, by = c("sci_name" = "scientificName")) %>% 
    select(assessmentId, internalTaxonId, sci_name, category) %>% 
    unique()

amphibians_info <- lapply(1:nrow(amphibians_nm), function(n){
    message(amphibians_nm[n, "sci_name"])
    parse_habitat_elevation(amphibians_nm[n, ], bio_data_dir, "amphibian")
})
save(amphibians_info, file = file.path(bio_data_dir, "amphibians_info.rda"))

# Birds
birds_nm <- birds %>% st_drop_geometry() %>% 
    select(sci_name, category) %>% 
    left_join(assessments, by = c("sci_name" = "scientificName")) %>% 
    select(assessmentId, internalTaxonId, sci_name, category) %>% 
    unique()

birds_info <- lapply(1:nrow(birds_nm), function(n){
    message(sprintf("No.%s: %s", n, birds_nm[n, "sci_name"]))
    parse_habitat_elevation(birds_nm[n, ], bio_data_dir, "bird")
})

save(birds_info, file = file.path(bio_data_dir, "birds_info.rda"))

# There are a few missing
birds_left <- do.call(
    rbind, lapply(birds_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(is.na(Habitat)) %>% pull(species)

# Do not include marine and artificial/aquatic
birds_left_info <- list(
    list(scientific_name = "Accipiter badius",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Forest", 2), rep("Savanna", 1), rep("Shrubland", 1),
                         rep("Grassland", 2), rep("Artificial/Terrestrial", 3)),
             Sub_habitat = c(
                 "Subtropical/Tropical Dry", "Subtropical/Tropical Moist Lowland", 
                 "Dry", 
                 "Subtropical/Tropical Dry", 
                 "Temperate", "Subtropical/Tropical Dry", 
                 "Plantations", "Rural Gardens", "Urban Areas"),
             Season = c(rep("Resident", 4), "Breeding season", rep("Resident", 4)),
             Suitability = c(rep("Suitable", 9)),
             Major_Importance = c(rep("No", 9))),
         lower_elevation = 0,
         upper_elevation = 2200),
    list(scientific_name = "Larus fuscus",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Grassland", 1), rep("Wetlands (inland)", 4), 
                         rep("Artificial/Terrestrial", 3)),
             Sub_habitat = c(
                 "Temperate", 
                 "Permanent Rivers/Streams/Creeks (includes waterfalls)", 
                 "Bogs, Marshes, Swamps, Fens, Peatlands", 
                 "Permanent Freshwater Lakes (over 8ha)",
                 "Seasonal/Intermittent Freshwater Lakes (over 8ha)", 
                 "Arable Land", "Pastureland",
                 "Urban Areas"),
             Season = c(rep("Breeding season", 4), 
                        rep("Non-Breeding season", 1), 
                        rep("Breeding season", 3)),
             Suitability = c(rep("Suitable", 8)),
             Major_Importance = c(rep("No", 8))),
         lower_elevation = NA,
         upper_elevation = NA),
    list(scientific_name = "Podiceps nigricollis",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Wetlands (inland)", 4)),
             Sub_habitat = c(
                 "Permanent Freshwater Marshes/Pools (under 8ha)", 
                 "Seasonal/Intermittent Freshwater Marshes/Pools (under 8ha)",
                 "Permanent Saline, Brackish or Alkaline Lakes",
                 "Permanent Saline, Brackish or Alkaline Marshes/Pools"),
             Season = c(rep("Breeding season", 2), "Non-breeding", "Breeding"),
             Suitability = c(rep("Suitable", 4)),
             Major_Importance = c(rep("Yes", 3), "No")),
         lower_elevation = NA,
         upper_elevation = 2500),
    list(scientific_name = "Buteo oreophilus",
         category = "NT",
         habitats = data.frame(
             Habitat = c(rep("Forest", 1), "Grassland"),
             Sub_habitat = c("Subtropical/Tropical Moist Montane",
                             "Subtropical/Tropical High Altitude"),
             Season = c(rep("Resident", 2)),
             Suitability = c(rep("Suitable", 1), "Marginal"),
             Major_Importance = c(rep("Yes", 1), "-")),
         lower_elevation = 2000,
         upper_elevation = 3800),
    list(scientific_name = "Acrocephalus griseldis",
         category = "EN",
         habitats = data.frame(
             Habitat = c(rep("Savanna", 1), "Shrubland", 
                         rep("Wetlands (inland)", 6)),
             Sub_habitat = c(
                 "Dry", "Subtropical/Tropical Moist", 
                 "Permanent Rivers/Streams/Creeks (includes waterfalls)",
                 "Permanent Freshwater Lakes (over 8ha)",
                 "Permanent Freshwater Marshes/Pools (under 8ha)",
                 "Freshwater Springs and Oases",
                 "Permanent Inland Deltas", 
                 "Permanent Saline, Brackish or Alkaline Marshes/Pools"),
             Season = c(rep("Non-Breeding season", 2), 
                        rep("Breeding season", 3), 
                        "Passage", rep("Breeding season", 2)),
             Suitability = c(rep("Suitable", 8)),
             Major_Importance = c(rep("No", 8))),
         lower_elevation = 0,
         upper_elevation = 1000),
    list(scientific_name = "Bubo africanus",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Forest", 1), "Savanna", "Shrubland", 
                         "Grassland", "Root", "Dssert", "Artificial/Terrestrial"),
             Sub_habitat = c("Subtropical/Tropical Dry", "Dry", 
                             "Subtropical/Tropical Dry",
                             "Subtropical/Tropical Dry", 
                             "Rocky areas (eg. inland cliffs, mountain peaks)", 
                             "Hot", "Rural Gardens"),
             Season = c(rep("Resident", 7)),
             Suitability = c(rep("Suitable", 7)),
             Major_Importance = c(rep("-", 7))),
         lower_elevation = 0,
         upper_elevation = 2100),
    list(scientific_name = "Butorides striata",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Forest", 1), "Grassland", 
                         rep("Wetlands (inland)", 3), 
                         rep("Artificial/Terrestrial", 2)),
             Sub_habitat = c(
                 "Subtropical/Tropical Mangrove Vegetation Above High Tide Level",
                 "Subtropical/Tropical Seasonally Wet/Flooded",
                 "Permanent Rivers/Streams/Creeks (includes waterfalls)",
                 "Shrub Dominated Wetlands", "Bogs, Marshes, Swamps, Fens, Peatlands",
                 "Arable Land", "Pastureland"),
             Season = c(rep("Resident", 7)),
             Suitability = c(rep("Suitable", 7)),
             Major_Importance = c(rep("No", 7))),
         lower_elevation = 0,
         upper_elevation = 1900),
    list(scientific_name = "Cisticola bakerorum",
         category = "VU",
         habitats = data.frame(
             Habitat = c(rep("Grassland", 1), "Wetlands (inland)"),
             Sub_habitat = c("Subtropical/Tropical Seasonally Wet/Flooded", 
                             "Bogs, Marshes, Swamps, Fens, Peatlands"),
             Season = c(rep("Resident", 2)),
             Suitability = c(rep("Suitable", 2)),
             Major_Importance = c(rep("Yes", 2))),
         lower_elevation = 240,
         upper_elevation = 305),
    list(scientific_name = "Oenanthe lugubris",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Grassland", 1), "Root", 
                         rep("Artificial/Terrestrial", 2)),
             Sub_habitat = c("Subtropical/Tropical Dry", 
                             "Rocky areas (eg. inland cliffs, mountain peaks)", 
                             "Arable Land", "Rural Gardens"),
             Season = c(rep("Resident", 4)),
             Suitability = c(rep("Suitable", 4)),
             Major_Importance = c(rep("Yes", 1), "-", rep("No", 2))),
         lower_elevation = 800,
         upper_elevation = 3000),
    list(scientific_name = "Bradypterus baboecala",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Wetlands (inland)", 1)),
             Sub_habitat = c("Bogs, Marshes, Swamps, Fens, Peatlands"),
             Season = c(rep("Resident", 1)),
             Suitability = c(rep("Suitable", 1)),
             Major_Importance = c(rep("Yes", 1))),
         lower_elevation = 0,
         upper_elevation = 2300),
    list(scientific_name = "Bradypterus centralis",
         category = "LC",
         habitats = data.frame(
             Habitat = c(rep("Wetlands (inland)", 1)),
             Sub_habitat = c("Bogs, Marshes, Swamps, Fens, Peatlands"),
             Season = c(rep("Resident", 1)),
             Suitability = c(rep("Suitable", 1)),
             Major_Importance = c(rep("Yes", 1))),
         lower_elevation = 0,
         upper_elevation = 2300),
    list(scientific_name = "Cisticola anderseni",
         category = "NT",
         habitats = data.frame(
             Habitat = c(rep("Grassland", 1), "Wetlands (inland)"),
             Sub_habitat = c("Subtropical/Tropical Seasonally Wet/Flooded",
                             "Bogs, Marshes, Swamps, Fens, Peatlands"),
             Season = c(rep("Resident", 2)),
             Suitability = c(rep("Suitable", 2)),
             Major_Importance = c(rep("Yes", 1), "No")),
         lower_elevation = 240,
         upper_elevation = 305),
    parse_habitat_elevation(
        birds_nm %>% 
            filter(sci_name == "Coracias naevius"), bio_data_dir, "bird")
)

save(birds_left_info, file = file.path(bio_data_dir, "birds_left_info.rda"))

# Reptiles
reptiles_nm <- reptiles %>% st_drop_geometry() %>% 
    select(sci_name, category) %>% 
    left_join(assessments, by = c("sci_name" = "scientificName")) %>% 
    select(assessmentId, internalTaxonId, sci_name, category) %>% 
    unique() %>% na.omit()

reptiles_info <- lapply(1:nrow(reptiles_nm), function(n){
    message(reptiles_nm[n, "sci_name"])
    parse_habitat_elevation(reptiles_nm[n, ], bio_data_dir, "reptile")
})
save(reptiles_info, file = file.path(bio_data_dir, "reptiles_info.rda"))
```

NOTE: A few manual edits were done due to the unavailability of pdf file.

INFO: check for messy formatting issues:

-   Mammals: no issues
-   Amphibians: no issues
-   Birds: no issues
-   reptiles: rarely no issues, easily can be fixed

#### Query habitat and elevation layers

We used [a global map of terrestrial habitat types as gridded reference habitat map](https://zenodo.org/record/4058819#.Y9LTLi-B30o) and ALOS DSM as the elevation reference to refine the range maps (1 km resolution from Google Earth Engine).

```{r}
# Convert to 1km planning unit
landcover <- rast(file.path(
    data_dir, "biodiversity/habitats",
    "iucn_habitatclassification_composite_lvl2_ver004.tif"))
landcover <- terra::aggregate(landcover, fact = 10, fun = "modal", cores = 10)
writeRaster(landcover, "data/biodiversity/habitats/habitats_1km.tif")

dsm_fname <- file.path(data_dir, "elevation/elevation.tif")
dsm <- rast(dsm_fname)
dsm <- resample(dsm, landcover)
writeRaster(dsm, file.path(data_dir, "elevation/elevation_1km.tif"))
```

    var dataset = ee.ImageCollection("JAXA/ALOS/AW3D30/V3_2");
    var elevation = dataset.select('DSM').mosaic();

    Export.image.toDrive({
      image: elevation,
      description: 'elevation',
      folder: 'reconcile',
      scale: 1000,
      crs: 'EPSG:4326',
      maxPixels: 1e13
    });

Define search table for habitat classes and map index.

```{r}
hbt_search_table <- data.frame(
    Habitat = c(
        rep("Forest", 9), rep("Savanna", 2), rep("Shrubland", 8), 
        rep("Grassland", 7), rep("Wetlands (inland)", 13), 
        "Root",
        rep("Desert", 3), rep("Artificial/Terrestrial", 5)),
    Sub_habitat = c(
        # Forest
        "Boreal", "Subarctic", "Subantarctic", "Temperate",
        "Subtropical/tropical dry", 
        "Subtropical/tropical moist lowland",
        "Subtropical/tropical mangrove vegetation above high tide level",
        "Subtropical/tropical swamp", "Subtropical/tropical moist montane",
        # Savanna
        "Dry", "Moist", 
        # Shrubland
        "Subarctic", "Subantarctic", "Boreal", "Temperate",
        "Subtropical/tropical dry", "Subtropical/tropical moist", 
        "Subtropical/tropical high altitude", 
        "Mediterranean-type shrubby vegetation",
        # Grassland
        "Tundra", 'Subarctic', 'Subantarctic', 'Temperate', 
        'Subtropical/tropical dry', 
        'Subtropical/tropical seasonally wet/flooded', 
        'Subtropical/tropical high altitude',
        # Wetlands (inland)
        'Permanent rivers/streams/creeks (includes waterfalls)',
        'Seasonal/intermittent/irregular rivers/streams/creeks',
        'Shrub dominated wetlands',
        'Bogs, marshes, swamps, fens, peatlands',
        'Permanent freshwater lakes (over 8 ha)',
        'Seasonal/intermittent freshwater lakes (over 8 ha)',
        'Permanent freshwater marshes/pools (under 8 ha)',
        'Seasonal/intermittent freshwater marshes/pools (under 8 ha)',
        'Tundra wetlands (inc. pools and temporary waters from snowmelt)',
        'Alpine wetlands (inc. temporary waters from snowmelt)',
        'Permanent inland deltas',
        'Permanent saline, brackish or alkaline lakes',
        'Seasonal/intermittent saline, brackish or alkaline lakes and flats',
        # Rocky areas
        "Rocky areas (eg. inland cliffs, mountain peaks)",
        # Desert
        "Hot", "Temperate", "Cold", 
        # Artificial/Terrestrial
        "Arable Land", "Pastureland", "Plantations",
        "Rural Gardens", "Urban Areas"),
    code = c(101:109, 201:202, 301:308, 401:407, 501:508, 
               510:511, 513:515, 600, 801:803, 1401:1405)) %>% 
    mutate(Habitat = tolower(Habitat),
           Sub_habitat = tolower(Sub_habitat))

# Set paths for layers
sf_use_s2(FALSE)
dsm_fname <- file.path(data_dir, "elevation/elevation_1km.tif")
lc_fname <- file.path(data_dir, "biodiversity/habitats/habitats_1km.tif")
dst_dir <- file.path(data_dir, "biodiversity/refined_range_maps")
```

#### Refine mammals

For mammals, we do not consider migratory or non-migratory species separately due to data deficient.

```{r}
# Read the raw table
habitat_mammals <- do.call(
    rbind, lapply(mammals_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(!(Season == "Passage" & Suitability == "Marginal")) %>% 
    filter(!Habitat %in% c("Caves", "Marine"))

# Check the habitats to see if there is any typo or so
unique(habitat_mammals$Habitat)
unique(habitat_mammals$Sub_habitat)

# Fix for possible typos
habitat_mammals <- habitat_mammals %>% 
    mutate(Sub_habitat = gsub(" Seasonal occurren ce", "", Sub_habitat))
    
# All level-1 and level-2 habitats are good to use
# Merge with habitat search table
habitat_mammals <- habitat_mammals %>% 
    mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
           Sub_habitat = gsub(" ", "", tolower(Sub_habitat))) %>% 
    left_join(
        hbt_search_table %>% 
            mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
                   Sub_habitat = gsub(" ", "", tolower(Sub_habitat))), 
        by = c("Habitat", "Sub_habitat")) %>% 
    # Artificial/Aquatic and 
    # Subtropical/Tropical Heavily Degraded Former Forest may be deleted
    # these habitats are covered by other types.
    filter(!is.na(code))

# Read elevation limits
ele_limits_mammals <- do.call(
    rbind, lapply(mammals_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)})) %>% 
    mutate(min_elevation = as.numeric(gsub(",", "", min_elevation)),
           max_elevation = as.numeric(gsub(",", "", max_elevation))) %>% 
    mutate(min_elevation = ifelse(is.na(min_elevation), -Inf, min_elevation),
           max_elevation = ifelse(is.na(max_elevation), Inf, max_elevation))

## Merge range polygons
## presence: 1, 2, origin: 1, 2, 6, season: 1
## so it is safe to merge multiple polygons for the same species
mammals <- read_sf(file.path(species_dir, "mammals_tz.geojson"))
mammals <- mammals %>% select(sci_name) %>% 
    group_by(sci_name) %>% 
    summarise(geometry = st_union(geometry)) %>% 
    ungroup()

# Refine the range maps
mammal_dst_dir <- file.path(dst_dir, "mammal")
if (!dir.exists(mammal_dst_dir)) dir.create(mammal_dst_dir)
mammals_map_refined <- lapply(174:nrow(mammals), function(n){
    # Read range
    this_mammal <- mammals[n, ] %>% st_make_valid()
    message(sprintf("No.%s: %s", n, this_mammal$sci_name))
    
    # Check if the map exists or not
    dst_path <- file.path(
        mammal_dst_dir, sprintf("%s.tif", this_mammal$sci_name))
    if (!file.exists(dst_path)) {
        # Habitat and elevation limits
    this_habitat <- habitat_mammals %>% 
        filter(species == this_mammal$sci_name)
    this_ele_limits <- ele_limits_mammals %>% 
        filter(species == this_mammal$sci_name)
    
    # Get land cover types
    landcover <- rast(lc_fname) %>% crop(this_mammal %>% st_buffer(1))
    
    # Select habitats
    if (length(unique(this_habitat$code)) > 0){
        landcover <- landcover %in% unique(this_habitat$code)}
    
    # Read and set layers
    dsm <- rast(dsm_fname) %>% crop(this_mammal %>% st_buffer(1))
    dsm <- (dsm >= this_ele_limits$min_elevation) & 
        (dsm <= this_ele_limits$max_elevation)
    # Sum the mask
    if (ext(landcover) != ext(dsm)){
        msk <- resample(dsm, landcover) & landcover
    } else {
        msk <- dsm & landcover
    }
    
    # Return a raster
    gmt <- rasterize(this_mammal, msk) * msk
    gmt[gmt == 0] <- NA
    if (!all(is.na(values(gmt)))){
        writeRaster(
            gmt, file.path(mammal_dst_dir, 
                           sprintf("%s.tif", this_mammal$sci_name)),
            datatype = "INT1U")}
    }
})
```

#### Refine amphibians

For amphibians, we do not consider migratory or non-migratory species separately due to data deficient. Also, we did not consider habitat Caves and Root due to not available land cover maps for this. We excluded marine, water habitats and only focus on terrestrial.

```{r}
# Read the raw table
amphibians <- read_sf(file.path(species_dir, "amphibians_tz.geojson"))
habitat_amphibians <- do.call(
    rbind, lapply(amphibians_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(!(Season == "Passage" & Suitability == "Marginal")) %>% 
    filter(!Habitat %in% c("Caves", "Marine"))

# Check the habitats to see if there is any typo or so
unique(habitat_amphibians$Habitat)
unique(habitat_amphibians$Sub_habitat)
    
# All level-1 and level-2 habitats are good to use
# Merge with habitat search table
habitat_amphibians <- habitat_amphibians %>% 
    mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
           Sub_habitat = gsub(" ", "", tolower(Sub_habitat))) %>% 
    left_join(
        hbt_search_table %>% 
            mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
                   Sub_habitat = gsub(" ", "", tolower(Sub_habitat))), 
        by = c("Habitat", "Sub_habitat")) %>% 
    # Artificial/Aquatic and 
    # Subtropical/Tropical Heavily Degraded Former Forest may be deleted
    # these habitats are covered by other types.
    # and waterbodies are not included in our analysis
    filter(!is.na(code))

# Read elevation limits
ele_limits_amphibians <- do.call(
    rbind, lapply(amphibians_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)})) %>% 
    mutate(min_elevation = as.numeric(gsub(",", "", min_elevation)),
           max_elevation = as.numeric(gsub(",", "", max_elevation))) %>% 
    mutate(min_elevation = ifelse(is.na(min_elevation), -Inf, min_elevation),
           max_elevation = ifelse(is.na(max_elevation), Inf, max_elevation))

## Merge range polygons
## presence: 1, 2, origin: 1, 2, 6, season: 1
## so it is safe to merge multiple polygons for the same species
amphibians <- amphibians %>% select(sci_name) %>% 
    group_by(sci_name) %>% 
    summarise(geometry = st_union(geometry)) %>% 
    ungroup()

# Refine the range maps
amphibian_dst_dir <- file.path(dst_dir, "amphibian")
if (!dir.exists(amphibian_dst_dir)) dir.create(amphibian_dst_dir)
amphibians_map_refined <- lapply(1:nrow(amphibians), function(n){
    # Read range
    this_amphibian <- amphibians[n, ] %>% st_make_valid()
    message(sprintf("No.%s: %s", n, this_amphibian$sci_name))
    
    # Check if the map exists or not
    dst_path <- file.path(
        amphibian_dst_dir, sprintf("%s.tif", this_amphibian$sci_name))
    if (!file.exists(dst_path)) {
        # Habitat and elevation limits
        this_habitat <- habitat_amphibians %>% 
            filter(species == this_amphibian$sci_name)
        this_ele_limits <- ele_limits_amphibians %>% 
            filter(species == this_amphibian$sci_name)
        
        # Get land cover types
        landcover <- rast(lc_fname) %>% crop(this_amphibian %>% st_buffer(1))
        
        # Select habitats
        if (length(unique(this_habitat$code)) > 0){
            landcover <- landcover %in% unique(this_habitat$code)}
        
        # Read and set layers
        dsm <- rast(dsm_fname) %>% crop(this_amphibian %>% st_buffer(1))
        dsm <- (dsm >= this_ele_limits$min_elevation) & 
            (dsm <= this_ele_limits$max_elevation)
        # Sum the mask
        if (ext(landcover) != ext(dsm)){
            msk <- resample(dsm, landcover) & landcover
        } else {
            msk <- dsm & landcover
        }
        
        # Return a raster
        gmt <- rasterize(this_amphibian, msk) * msk
        gmt[gmt == 0] <- NA
        if (!all(is.na(values(gmt)))){
            writeRaster(gmt, dst_path, datatype = "INT1U")}
    }
})
```

#### Refine reptiles

For reptiles, we do not consider migratory or non-migratory species separately due to data deficient. Also, we did not consider habitat Caves and Root due to not available land cover maps for this. We excluded marine, water habitats and only focus on terrestrial.

```{r}
# Read the raw table
habitat_reptiles <- do.call(
    rbind, lapply(reptiles_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(!(Season == "Passage" & Suitability == "Marginal")) %>% 
    filter(!Habitat %in% c("Caves", "Marine"))

# Check the habitats to see if there is any typo or so
unique(habitat_reptiles$Habitat)
unique(habitat_reptiles$Sub_habitat)

# Fix for possible typos
habitat_reptiles <- habitat_reptiles %>% 
    mutate(Sub_habitat = gsub(" Seasonal occurren ce", "", Sub_habitat))
    
# All level-1 and level-2 habitats are good to use
# Merge with habitat search table
habitat_reptiles <- habitat_reptiles %>% 
    mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
           Sub_habitat = gsub(" ", "", tolower(Sub_habitat))) %>% 
    left_join(
        hbt_search_table %>% 
            mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
                   Sub_habitat = gsub(" ", "", tolower(Sub_habitat))), 
        by = c("Habitat", "Sub_habitat")) %>% 
    # Artificial/Aquatic and 
    # Subtropical/Tropical Heavily Degraded Former Forest may be deleted
    # these habitats are covered by other types.
    # and waterbodies are not included in our analysis
    filter(!is.na(code))

# Read elevation limits
ele_limits_reptiles <- do.call(
    rbind, lapply(reptiles_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)})) %>% 
    mutate(min_elevation = as.numeric(gsub(",", "", min_elevation)),
           max_elevation = as.numeric(gsub(",", "", max_elevation))) %>% 
    mutate(min_elevation = ifelse(is.na(min_elevation), -Inf, min_elevation),
           max_elevation = ifelse(is.na(max_elevation), Inf, max_elevation))

## Merge range polygons
## presence: 1, 2, origin: 1, 2, 6, season: 1
## so it is safe to merge multiple polygons for the same species
reptiles <- reptiles %>% select(sci_name) %>% 
    group_by(sci_name) %>% 
    summarise(geometry = st_union(geometry)) %>% 
    ungroup()

# Refine the range maps
reptile_dst_dir <- file.path(dst_dir, "reptile")
if (!dir.exists(reptile_dst_dir)) dir.create(reptile_dst_dir)
reptiles_map_refined <- lapply(1:nrow(reptiles), function(n){
    # Read range
    this_reptile <- reptiles[n, ] %>% st_make_valid()
    message(sprintf("No.%s: %s", n, this_reptile$sci_name))
    
    # Check if the map exists or not
    dst_path <- file.path(
        reptile_dst_dir, sprintf("%s.tif", this_reptile$sci_name))
    if (!file.exists(dst_path)) {
        # Habitat and elevation limits
    this_habitat <- habitat_reptiles %>% 
        filter(species == this_reptile$sci_name)
    this_ele_limits <- ele_limits_reptiles %>% 
        filter(species == this_reptile$sci_name)
    
    # Get land cover types
    landcover <- rast(lc_fname) %>% crop(this_reptile %>% st_buffer(1))
    
    # Select habitats
    if (length(unique(this_habitat$code)) > 0){
        landcover <- landcover %in% unique(this_habitat$code)}
    
    # Read and set layers
    if (nrow(this_ele_limits) > 0){
        dsm <- rast(dsm_fname) %>% crop(this_reptile %>% st_buffer(1))
        dsm <- (dsm >= this_ele_limits$min_elevation) & 
            (dsm <= this_ele_limits$max_elevation)
        # Sum the mask
        if (ext(landcover) != ext(dsm)){
            msk <- resample(dsm, landcover) & landcover
        } else {
            msk <- dsm & landcover
        }
    } else msk <- landcover
    
    # Return a raster
    gmt <- rasterize(this_reptile, msk) * msk
    gmt[gmt == 0] <- NA
    if (!all(is.na(values(gmt)))){
        writeRaster(gmt, dst_path, datatype = "INT1U")}
    } else {
        message("File has been created.")
    }
})
```

#### Refine birds

For birds, we consider migratory (breeding) or non-migratory (non-breeding) species separately due to data deficient. Also, we did not consider habitat Caves and Root due to not available land cover maps for this. We excluded marine, water habitats and only focus on terrestrial.

```{r}
# Read the raw table
habitat_birds <- do.call(
    rbind, lapply(birds_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(!is.na(Habitat)) %>% 
    rbind(do.call(
    rbind, lapply(birds_left_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)}))) %>% 
    filter(Season != "Passage") %>%
    filter(!Habitat %in% c("Caves", "Marine")) %>% 
    mutate(Habitat = ifelse(Habitat == "Dssert", "Desert", Habitat))
    
# Check the habitats to see if there is any typo or so
unique(habitat_birds$Habitat)
unique(habitat_birds$Sub_habitat)
unique(habitat_birds$Season)
unique(habitat_birds$Suitability)

# If the list is too long, use some references to filter
setdiff(gsub(" ", "", tolower(unique(habitat_birds$Sub_habitat))),
        gsub(" ", "", tolower(hbt_search_table$Sub_habitat)))

# Fix for possible typos
habitat_birds[is.na(habitat_birds$Sub_habitat), ] <- 
    c("Artificial/Terrestrial", "Arable Land", 
      "Non-breeding season", "-", "-", "Gallinago media")
habitat_birds[habitat_birds$species == "Cercococcyx mechowi", ] <- 
    c("Forest", "Subtropical/Tropical Moist Lowland", 
      "Resident", "Suitable", "Yes", "Gallinago media")
habitat_birds <- habitat_birds %>% 
    mutate(Sub_habitat = gsub(" Seasonal occurren ce", "", Sub_habitat))
    
# All level-1 and level-2 habitats are good to use
# Merge with habitat search table
habitat_birds <- habitat_birds %>% 
    mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
           Sub_habitat = gsub(" ", "", tolower(Sub_habitat))) %>% 
    left_join(
        hbt_search_table %>% 
            mutate(Habitat = gsub(" ", "", tolower(Habitat)), 
                   Sub_habitat = gsub(" ", "", tolower(Sub_habitat))), 
        by = c("Habitat", "Sub_habitat")) %>% 
    # Artificial/Aquatic and 
    # Subtropical/Tropical Heavily Degraded Former Forest may be deleted
    # these habitats are covered by other types.
    # and waterbodies are not included in our analysis
    filter(!is.na(code))

# Read elevation limits
birds_left <- do.call(
    rbind, lapply(birds_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(is.na(Habitat)) %>% pull(species)

ele_limits_birds <- do.call(
    rbind, lapply(birds_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)})) %>% 
    filter(!species %in% birds_left) %>% 
    rbind(do.call(
    rbind, lapply(birds_left_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)}))) %>% 
    mutate(min_elevation = as.numeric(gsub(",", "", min_elevation)),
           max_elevation = as.numeric(gsub(",", "", max_elevation))) %>% 
    mutate(min_elevation = ifelse(is.na(min_elevation), -Inf, min_elevation),
           max_elevation = ifelse(is.na(max_elevation), Inf, max_elevation))

## Merge range polygons
## presence: 1, 2, origin: 1, 2, 6
## separate seasonality 
## resident (1), breeding season (2) and non-breeding season (3)
unique(habitat_birds$Season)

# Format the seasonal column
habitat_birds <- habitat_birds %>% 
    mutate(seasonal = ifelse(
        str_detect(habitat_birds$Season, "Non-breeding|Non-Breeding"), 3, 
        ifelse(str_detect(habitat_birds$Season, "Breeding"), 2, 1)))

unique(habitat_birds$seasonal)

birds <- birds %>% select(sci_name, seasonal) %>% 
    group_by(sci_name, seasonal) %>% 
    summarise(geometry = st_union(geometry)) %>% 
    ungroup()

# Refine the range maps
bird_dst_dir <- file.path(dst_dir, "bird")
if (!dir.exists(bird_dst_dir)) dir.create(bird_dst_dir)
birds_map_refined <- mclapply(unique(birds$sci_name), function(nm){
    # Read range
    this_bird <- birds %>% filter(sci_name == nm) %>% st_make_valid()
    message(sprintf("No.%s: %s", which(unique(birds$sci_name) == nm), nm))
    
    # Check if the map exists or not
    dst_path <- file.path(
        bird_dst_dir, sprintf("%s.tif", nm))
    if (!file.exists(dst_path)) {
        # Habitat and elevation limits
        this_habitat <- habitat_birds %>% 
            filter(species == nm)
        this_ele_limits <- ele_limits_birds %>% 
            filter(species == nm)
        
        # Get land cover types
        landcover <- rast(lc_fname) %>% crop(this_bird %>% st_buffer(1))
        
        # Read and set layers
        dsm <- rast(dsm_fname) %>% crop(this_bird %>% st_buffer(1))
        dsm <- (dsm >= this_ele_limits$min_elevation) & 
            (dsm <= this_ele_limits$max_elevation)
        
        gmt <- lapply(unique(this_bird$seasonal), function(season){
            seasonal_bird <- this_bird %>% filter(seasonal == season)
            seasonal_habitat <- this_habitat %>% 
                filter(seasonal == season)
            
            # Select habitats
            if (length(unique(seasonal_habitat$code)) > 0){
                lc <- landcover %in% unique(seasonal_habitat$code)
            } else lc <- landcover
            
            # Sum the mask
            if (ext(lc) != ext(dsm)){
                msk <- resample(dsm, lc) & lc
            } else {
                msk <- dsm & lc
            }
            
            # Return a raster
            gmt <- rasterize(seasonal_bird, msk) * msk
            gmt[gmt == 0] <- NA
            if (!all(is.na(values(gmt)))){
                writeRaster(
                    gmt, file.path(
                        bird_dst_dir, 
                        sprintf("%s_%s.tif", seasonal_bird$sci_name, season)),
                    datatype = "INT1U", overwrite = TRUE)}
            
            # Return
            gmt
        })
        
        if (length(gmt) > 1) {
            gmt <- do.call(mosaic, gmt)
        } else gmt <- gmt[[1]]
        
        
        if (!all(is.na(values(gmt)))){
            writeRaster(gmt, dst_path, datatype = "INT1U")}
    }
}, mc.cores = 6)
```

### Calculate biodiversity indices

-   Species richness
-   Species endemism (Rarity-weighted richness)
-   Small-ranged species richness

```{r}
library(MASS)
library(geojsonsf)
sf_use_s2(FALSE)

# Set paths
range_dir <- file.path(bio_data_dir, "refined_range_maps")
dst_dir <- file.path(bio_data_dir, "species_richness")
if (!dir.exists(dst_dir)) dir.create(dst_dir)

# Make a boundary
bry_buf <- bry %>% st_buffer(0.1)

taxon_group <- c("mammal", "amphibian", "bird", "reptile")

# Get range sizes for the refined maps (1 km resolution)
ranges_sizes <- do.call(rbind, lapply(taxon_group, function(taxon){
    # Get the list of species
    fnames <- list.files(
        file.path(range_dir, taxon), full.names = TRUE)
    if (taxon == "bird") fnames <- fnames[!grepl("[1-3]{1}", fnames)]
    
    species <- tools::file_path_sans_ext(basename(fnames))
    
    range_size <- mclapply(fnames, function(fname){
        rg <- rast(fname)
        sum(values(rg), na.rm = TRUE)}, mc.cores = 12)
    data.frame(taxon = taxon,
               species = species,
               ranges_size = unlist(range_size))
}))
save(ranges_sizes, file = file.path(bio_data_dir, "ranges_sizes.rda"))

# Get local species
local_species <- lapply(taxon_group, function(taxon){
    # Get the list of species
    fnames <- list.files(
        file.path(range_dir, taxon), full.names = TRUE)
    if (taxon == "bird") fnames <- fnames[!grepl("[1-3]{1}", fnames)]
    
    species <- tools::file_path_sans_ext(basename(fnames))
    
    is_local <- unlist(mclapply(fnames, function(fname){
        rg <- rast(fname)
        rg_tz <- rg %>% crop(bry) %>% terra::mask(bry)
        if (sum(values(rg), na.rm = TRUE) == 
            sum(values(rg_tz), na.rm = TRUE)){
            TRUE
        } else FALSE
        }, mc.cores = 12))
    # return
    species[is_local]
})
names(local_species) <- taxon_group
save(local_species, file = file.path(bio_data_dir, "local_species.rda"))

mammals <- geojson_sf(here(species_dir, "mammals_global.geojson"))
amphibians <- geojson_sf(here(species_dir, "amphibians_global.geojson"))
birds <- geojson_sf(here(species_dir, "birds_global.geojson"))
reptiles <- geojson_sf(here(species_dir, "reptiles_global_iucn.geojson"))

raw_range_sizes <- mammals %>% select(sci_name) %>% mutate(taxon = "mammal") %>% 
    rbind(amphibians %>% select(sci_name) %>% mutate(taxon = "amphibian")) %>% 
    rbind(reptiles_iucn %>% select(sci_name) %>% mutate(taxon = "reptile")) %>% 
    st_cast("MULTIPOLYGON") %>% 
    rbind(birds %>% select(sci_name) %>% mutate(taxon = "bird") %>% 
              select(sci_name, taxon, geometry)) %>% 
    mutate(area = st_area(.) %>% units::set_units("km2")) %>% 
    st_drop_geometry() %>% 
    group_by(taxon, sci_name) %>% summarise(area = sum(area)) %>% 
    ungroup()
save(raw_range_sizes, file = file.path(bio_data_dir, "raw_range_sizes.rda"))

# Calculate the median of refined global range sizes for each taxonomic groups
rrange_refrange <- left_join(
    ranges_sizes, raw_range_sizes %>% select(-taxon), 
    by = c("species" = "sci_name")) %>% 
    na.omit() %>% 
    rename(refined_range_size = ranges_size, range_size = area)

global_medians <- do.call(rbind, lapply(taxon_group, function(txn){
    dt <- rrange_refrange %>% filter(taxon == txn)
    message("Cor: ", cor(dt$refined_range_size, dt$range_size))
    mod <- rlm(refined_range_size ~ 0 + range_size, data = dt)
    
    # Global median
    # Reference number from other study (Crawford et al. 2021)
    # mammal: 170,594.24 km2 (old pre dropping EW EX: 170568.45 km2
    # amphibian: 4,443.1651 km2 (old pre dropping EW EX: 4439.1885 km2)
    # bird: 471064.67 km2 (even after dropping EW EX)
    # reptile: 16,955.5827 km2 (old pre dropping EW EX: 16917.3988 km2)
    median <- raw_range_sizes %>% filter(taxon == txn) %>% 
            pull(area) %>% median()
    refined_median <- median(predict(
        mod, raw_range_sizes %>% filter(taxon == txn) %>% 
            rename(range_size = area) %>% select(range_size)))
    data.frame(taxon = txn,
               median = median,
               refined_median = refined_median)
}))
save(global_medians, file = file.path(bio_data_dir, "global_medians.rda"))

# Calculate the richness
# Make a raster template
template <- rast(file.path(range_dir, "mammal/Acinonyx jubatus.tif")) %>% 
    crop(bry_buf) %>% terra::mask(bry_buf)
values(template) <- 0
for (txn in taxon_group){
    message(sprintf("Taxonomic group: %s", txn))
    # Set weights
    global_median <- global_medians %>% 
        filter(taxon == txn) %>% pull(refined_median)
    lc_species <- local_species[[txn]]
    calc_weights <- read_sf(
        file.path(species_dir, sprintf("%ss_tz.geojson", txn))) %>% 
        st_drop_geometry() %>% select(sci_name, category) %>% unique() %>% 
        left_join(ranges_sizes %>% select(-taxon), 
                  by = c("sci_name" = "species")) %>% 
        mutate(range_weight = ifelse(ranges_size < global_median, 1, 1/2),
               local_weight = ifelse(sci_name %in% lc_species, 1, 1/2)) %>% 
        na.omit() %>% 
        mutate(threat_weight = 
            ifelse(category == "CR", 1,
            ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
            ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
            ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
            ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
            # if DD then 1/4 (a middle ground, conservative estimate).
            ifelse(category == "DD", 1/4, 0)))))))  # If not, then -> 0.
    
    # Check the threat weights
    message(sprintf("Any invalid category?: %s", 
                    any(calc_weights$threat_weight == 0)))
    
    # Get the list of species
    fnames <- list.files(
        file.path(range_dir, txn), full.names = TRUE)
    if (txn == "bird") fnames <- fnames[!grepl("[1-3]{1}", fnames)]
    species <- tools::file_path_sans_ext(basename(fnames))
    
    # Check file numbers
    message(sprintf("File lengths are the same?: %s", 
                    identical(length(fnames), length(species))))
    
    # Richness
    message("Weighted richness/weighted endemism richness.")
    sr <- rast(template, vals = 0)
    rwsr <- rast(template, vals = 0)
    wsr <- rast(template, vals = 0)
    wrwsr <- rast(template, vals = 0)
    for (fname in fnames){
        ## Species richness----------------------------------------------------
        rg <- rast(fname) %>% crop(bry_buf) %>% terra::mask(bry_buf)
        rg <- extend(rg, ext(sr))
        rg[is.na(rg)] <- 0
        
        ## Endemism_richness---------------------------------------------------
        global_sz <- ranges_sizes %>% 
            filter(species == tools::file_path_sans_ext(basename(fname))) %>% 
            pull(ranges_size)
        rrg <- rg / global_sz
        
        ## Weighted richness---------------------------------------------------
        t_weights <- calc_weights %>% 
            filter(sci_name == tools::file_path_sans_ext(basename(fname)))
        t_weight <- t_weights$threat_weight * t_weights$range_weight * 
            t_weights$local_weight
        wrg <- rg * t_weight
        
        ## Weighted endemism richness------------------------------------------
        wrrg <- rrg * t_weight
        
        # Accumulate species
        sr <- sr + rg
        rwsr <- rwsr + rrg
        wsr <- wsr + wrg
        wrwsr <- wrwsr + wrrg
        
        # Clean
        rm(rg, rrg, wrg, wrrg)}
    
    # Write out final layers
    writeRaster(
        sr, file.path(dst_dir, sprintf("species_richness_%s.tif", txn)))
    writeRaster(
        rwsr, file.path(dst_dir, sprintf("endemism_richness_%s.tif", txn)))
    writeRaster(
        wsr, file.path(dst_dir, sprintf("weighted_richness_%s.tif", txn)))
    writeRaster(
        wrwsr, file.path(dst_dir, sprintf("weighted_endemism_richness_%s.tif", txn)))
    rm(sr, rwsr, wsr, wrwsr) # Clean up
}
```

## Ecosystem level

We used CSIRO Biodiversity Habitat Index (BHI) as the evaluation of local habitat importance and took GLOBIO Mean Species Abundance (MSA) and PREDICTS Biodiversity Intactness Index (BII) as measures of regional ecosystem intactness.

```{r}
bbox_ll <- bry %>% st_bbox() %>% 
    st_as_sfc() %>% st_buffer(1)

# Read metrics
bhi <- rast(file.path(bio_data_dir, "BILBI_P_BHIv2_Habitat_2020.tif")) %>% 
    crop(bbox_ll)
msa <- rast(file.path(bio_data_dir, "TerrestrialMSA_2015_World.tif")) %>% 
    crop(bbox_ll) %>% resample(bhi)
bii <- rast(file.path(bio_data_dir, "lbii.asc")) %>% 
    crop(bbox_ll)

# save out
bhi_msa_bii <- c(bhi, msa, bii)
names(bhi_msa_bii) <- c("BHI", "MSA", "BII")
writeRaster(bhi_msa_bii, file.path(bio_data_dir, "bhi_msa_bii.tif"))
```

## Composite biodiversity indices

We calculated composite biodiversity indicators (BIp and BIr) according to [@soto-navarro2020]. We modified $S_{i}$ to include more aspects.

```{r}
# Calculate biodiversity indicator
# Reference: Soto-Navarro et al. 2020
# BIp <- b * c
# b = S (species component) + E (ecosystems component)
# c is BHI
# S is the geometric mean of SR and RWR
# E is the arithmetic mean of MSA and BII

# Read files
bhi_msa_bii <- rast(file.path(bio_data_dir, "bhi_msa_bii.tif"))

# Calculate species component
normalize <- function(x, robust = FALSE) {
    if (robust){
        stretch(x, minv = 0, maxv = 1, minq = 0, maxq = 0.95)
    } else {
        (x - minmax(x)[1]) / (minmax(x)[2] - minmax(x)[1])
    }
}

richness_dir <- file.path(bio_data_dir, "species_richness")
taxon_group <- c("mammal", "amphibian", "bird", "reptile")
fnames <- list.files(richness_dir, full.names = TRUE)

richness_fns <- fnames[grepl("weighted", fnames) & !grepl("endemism", fnames)]
richness <- do.call(
    c, lapply(richness_fns, function(fn){
    normalize(rast(fn) %>% mask(bry_buf))})) %>% mean() %>% normalize()

endemism_fns <- fnames[grepl("weighted", fnames) & grepl("endemism", fnames)]
# Use 0-95% stretch because of some outlier values
endemism <- do.call(
    c, lapply(endemism_fns, function(fn){
    normalize(rast(fn) %>% mask(bry_buf), TRUE)})) %>% mean() %>% normalize()

# Geometric mean for species richness and endemism richness
# (the Nth root of the product of N numbers - 
# in the case of combining two layers x and y, 
# a pixels value would be the square root of x*y)
S <- sqrt(richness * endemism)

# Calculate ecosystems component
# Arithmetic mean for MSA and BII
# (the Nth root of the product of N numbers - 
# in the case of combining two layers x and y, 
# a pixels value would be the square root of x*y)
E <- mean(bhi_msa_bii[["MSA"]], bhi_msa_bii[["BII"]])

# Calculate biodiversity indicators
b <- resample(S, E) + E
c <- bhi_msa_bii[["BHI"]]
BIp <- b * c

# Save out
# NOTE: the values outside of Tanzania is not valid
# because species components does not cover these areas.
names(BIp) <- "BIp"
writeRaster(BIp, file.path(trdeoff_dir, "BIp.tif"))
```
