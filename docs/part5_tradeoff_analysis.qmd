---
title: "Part5: tradeoff analysis"
author: "Lei Song"
editor: visual
toc: true
toc-depth: 2
number-sections: false
toc-location: left
output: 
  html:
      theme: journal
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

# Load packages
# remotes::install_github(repo = "floswald/GAEZr")
library(sf)
library(here)
library(dplyr)
library(stringr)
library(osmdata)
library(terra)
select <- dplyr::select

# Set paths
data_dir <- here("data/landcover")
result_dir <- here("results")
trdeoff_dir <- here("data/tradeoff")
```

## Prepare layer masks

In this step, we masked out waterbodies, settlement, and protected areas from all layers. We also masked out any potential areas outside of Tanzania boundary. The masks prepared in this step could be considered as the land that cannot be touched at all. It may not always be true that the settlements cannot be relocated, but settlements relocation is a complex evaluation not only based on ecological facts, but also based on many other factors. So we did not consider this in this analysis.

Also, we only considered permanent and large enough waterbodies mainly because of the lack of data. This may overestimate the land can expand, not too much though.

We separated the protected area mask from the other two in order to consider clearing agriculture within protected areas.

```{r}
sf_use_s2(FALSE)
# Study area
bry <- read_sf(here("data/geoms/mainland_tanzania.geojson")) %>% 
    select()

# Query waterbodies and large rivers from OSM
waterbodies <- opq(bbox = st_bbox(bry), timeout = 1000) %>% 
    add_osm_feature("natural", "water") %>% 
    osmdata_sf()
waterbodies <- waterbodies$osm_polygons %>% select(osm_id) %>% 
    st_cast("MULTIPOLYGON") %>% 
    rbind(waterbodies$osm_multipolygons %>% select(osm_id))
waterbodies <- waterbodies %>% 
    mutate(area = st_area(.) %>% units::set_units("km2")) %>% 
    filter(area > 0.5 %>% units::set_units("km2"))
write_sf(waterbodies, file.path(data_dir, "waterbodies.geojson"))

## Wetlands (including water)
wetlands <- rast(
    file.path(data_dir, "TROP-SUBTROP_WetlandV3b_2016_CIFOR",
              "TROP-SUBTROP_WetlandV3b_2016_CIFOR.tif")) %>% 
    crop(bry) %>% mask(bry)
wetlands[!is.na(wetlands)] <- 1

## Built-up areas
builtup <- rast(file.path(data_dir, "landcover_tz_1km.tif"))
builtup[builtup != 6] <- NA; builtup[builtup == 6] <- 1

## Protected areas, we considered all types of protected areas
pas <- read_sf(
    file.path("data/protected_area", "WDPA_WDOECM_Jan2023_Public_TZA",
              "WDPA_WDOECM_Jan2023_Public_TZA.gdb"),
    layer = "WDPA_WDOECM_poly_Jan2023_TZA")
pas <- pas %>% 
    select(WDPAID, NAME, DESIG) %>% 
    rename(Geometry = SHAPE) %>% 
    filter(!DESIG %in% c("Marine Reserve", "Marine Park"))

# Add buffer zone, 5km, to non-forest PAs
pas <- pas %>% filter(str_detect(DESIG, "Forest|forest")) %>% 
    rbind(pas %>% filter(!str_detect(DESIG, "Forest|forest")) %>% 
                             st_buffer(0.008333333 * 5))
```

## Format the input layers

```{r}
# Read layers
fnames <- list.files(trdeoff_dir, full.names = TRUE)

template <- rast(fnames[1]) %>% crop(bry) %>% mask(bry)
fnames_80 <- fnames[!str_detect(fnames, "60")]
inputs_80 <- do.call(c, lapply(fnames_80, function(fname){
    if (str_detect(fname, "carbon")){
        rast(fname) %>% resample(template) %>% 
            crop(bry) %>% mask(bry)
    } else {
        rast(fname) %>% crop(bry) %>% mask(bry)
    }
}))

fnames_60 <- fnames[!str_detect(fnames, "80")]
inputs_60 <- do.call(c, lapply(fnames_60, function(fname){
    if (str_detect(fname, "carbon")){
        rast(fname) %>% resample(template) %>% 
            crop(bry) %>% mask(bry)
    } else {
        rast(fname) %>% crop(bry) %>% mask(bry)
    }
}))

names(inputs_80) <- c(
    "biodiversity_cost", "carbon_cost", 
    "elephant_cons_index", "potential_production", 
    "production_gain", "travel_time")
names(inputs_60) <- c(
    "biodiversity_cost", "carbon_cost", 
    "elephant_cons_index", "potential_production", 
    "production_gain", "travel_time")

# Apply masks
## Waters + settlements
waterbodies <- rasterize(waterbodies, template)
wetlands <- resample(wetlands, template, method = "near")
builtup <- project(builtup, template, method = "near")
msk <- mean(waterbodies, wetlands, builtup, na.rm = TRUE)
writeRaster(msk, file.path(result_dir, "water_settlement_mask.tif"))
msk <- msk %>% crop(bry) %>% mask(bry)

## PAs
pas <- rasterize(pas, template, values = 1)
writeRaster(pas, file.path(result_dir, "pas_mask.tif"))
pas <- pas %>% crop(bry) %>% mask(bry)

## Mask out waters and settlements from inputs
inputs_80 <- mask(inputs_80, msk, inverse = TRUE)
writeRaster(inputs_80, file.path(result_dir, "tradeoff_inputs_80.tif"))
inputs_60 <- mask(inputs_60, msk, inverse = TRUE)
writeRaster(inputs_60, file.path(result_dir, "tradeoff_inputs_60.tif"))
```

So far, the inputs are ready to be used in the trade-off analysis workflow.

## Trade-off analysis

### Prepare inputs for the analysis

In this part, we processed and prepared the inputs for the analysis. They include:

-   Future production, this would be used to calculate the food need to meet the target
-   Standardized production gain layer, this would be the base assessment to evaluate where to develop
-   Standardized biodiversity cost
-   Standardized carbon cost
-   Standardized elephant conservation cost
-   Nonconvertible land mask to constraint the agricultural expansion

The spatial planning unit is 1 square km (100 ha). The evaluation unit is per production gain.

```{r}
# Mask out PAs
inputs_80 <- mask(inputs_80, pas, inverse = TRUE)
inputs_60 <- mask(inputs_60, pas, inverse = TRUE)

# Normalize
inputs_80_std <- do.call(c, lapply(names(inputs_80), function(name){
    lyr <- inputs_80[[name]]
    if (name == "production_gain") {
        lyr <- stretch(lyr, minv = 0, maxv = 1)
    } else if (name == "potential_production") {
        lyr <- lyr
    } else {
        lyr <- 1 - stretch(lyr, minv = 0, maxv = 1)
    }
    lyr
}))

inputs_60_std <- do.call(c, lapply(names(inputs_60), function(name){
    lyr <- inputs_60[[name]]
    if (name == "production_gain") {
        lyr <- stretch(lyr, minv = 0, maxv = 1)
    } else if (name == "potential_production") {
        lyr <- lyr
    } else {
        lyr <- 1 - stretch(lyr, minv = 0, maxv = 1)
    }
    lyr
}))

# Save out
writeRaster(
    inputs_80_std, file.path(result_dir, "tradeoff_inputs_80_std.tif"),
    overwrite = TRUE)
writeRaster(
    inputs_60_std, file.path(result_dir, "tradeoff_inputs_60_std.tif"),
    overwrite = TRUE)
```

### Run the experiments

Okay, fine. I will simplify and reconstruct the workflow according to the theories behind `agriEcoTradeoff` based on the data in this study.

```{r}
# Load function
source("scripts/land_allocate.R")

# Set parameters
## Roughly 4-folds of current production
production_need <- 50000000

# Equally consider all factors
cbetas_bcep <- c(
    "biodiversity_cost" = 1/5, "carbon_cost" = 1/5, 
    "elephant_cons_index" = 1/5, "production_gain" = 1/5, 
    "travel_time" = 1/5)

# 80 scenario
land_allocate(
    inputs_80_std[["potential_production"]], inputs_80_std, 
    production_need, cbetas_bcep, result_dir,
    "bcep_80")
# 60 scenario
land_allocate(
    inputs_60_std[["potential_production"]], inputs_60_std, 
    production_need, cbetas_bcep, result_dir,
    "bcep_60")

cbetas_bcp <- c(
    "biodiversity_cost" = 1/4, "carbon_cost" = 1/4, 
    "elephant_cons_index" = 0, "production_gain" = 1/4,
    "travel_time" = 1/4)

# 80 scenario
land_allocate(
    inputs_80_std[["potential_production"]], inputs_80_std, 
    production_need, cbetas_bcp, result_dir,
    "bcp_80")
# 60 scenario
land_allocate(
    inputs_60_std[["potential_production"]], inputs_60_std, 
    production_need, cbetas_bcp, result_dir,
    "bcp_60")

cbetas_bce <- c(
    "biodiversity_cost" = 1/4, "carbon_cost" = 1/4, 
    "elephant_cons_index" = 1/4, "production_gain" = 0,
    "travel_time" = 1/4)

# 80 scenario
land_allocate(
    inputs_80_std[["potential_production"]], inputs_80_std, 
    production_need, cbetas_bce, result_dir,
    "bce_80")
# 60 scenario
land_allocate(
    inputs_60_std[["potential_production"]], inputs_60_std, 
    production_need, cbetas_bce, result_dir,
    "bce_60")
```

