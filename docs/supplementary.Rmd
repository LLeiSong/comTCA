---
title: "Supplementaries: dataset, code, references, etc"
author: "Lei Song"
date: "1/7/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Dataset

**Agriculture/crop:**

- [National Sample Census of Agriculture (Tanzania)](https://www.nbs.go.tz/index.php/en/census-surveys/agriculture-statistics) and [dataset download port](https://www.nbs.go.tz/tnada/index.php/catalog/31/get-microdata)
- [Global Agro-Ecological Zones (GAEZ v4)](https://gaez.fao.org)
- [European Commission](https://mars.jrc.ec.europa.eu/asap/country.php?cntry=257)
- [SoilGrids](https://www.isric.org/explore/soilgrids), [Soil property maps of Africa](https://www.isric.org/projects/soil-property-maps-africa-250-m-resolution), and [all available dataset list](https://data.isric.org/geonetwork/srv/eng/catalog.search;jsessionid=D59E70CBD401A199C806783D11B4B656#/search?facet.q=type%2Fdataset%26mdActions%2FmdActions-download&resultType=details&sortBy=relevance&any=soilgrids250m&from=1&to=20&fast=index&_content_type=json)
- [African iSDAsoil dataset at 30 m resolution (Hengl et al., 2021)](https://zenodo.org/search?q=iSDAsoil)

**Biomass/above-ground carbon:**

- [Literature (Ross, et.al., 2021)](https://figshare.com/articles/dataset/Biomass_prediction_maps/14150210/2)
- [NCEO aboveground Biomass 2017](https://leicester.figshare.com/articles/dataset/Africa_Aboveground_Biomass_map_for_2017/15060270)


**Water/hydrology**

- [Global Aridity Index and Potential Evapotranspiration](https://cgiarcsi.community/2019/01/24/global-aridity-index-and-potential-evapotranspiration-climate-database-v3/)

**Biodiversity/species:**

- [Reptile distribution](http://www.gardinitiative.org/data.html)
- [BirdLife (Bird distribution)](http://datazone.birdlife.org/species/requestdis)
- [IUCN Red List (Species distribution)](https://www.iucnredlist.org/resources/spatial-data-download)

**Multiple datasets for conservation:**

- [UNBiodiversity Lab](https://unbiodiversitylab.org) and its [document](https://unbiodiversitylab.org/wp-content/uploads/2021/02/UNBL_Data_February_2021.pdf)


## Some candidate datasets to use

We used the Global Surface Summary of the Day (GSOD) dataset shared by NOAA National Centers for Environmental Information (directly from [this link](https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C00516)). This dataset includes Mean temperature, Mean dew point, Mean wind speed, Maximum temperature, Minimum temperature, Precipitation amount (see more details [here](https://www.ncei.noaa.gov/data/global-summary-of-the-day/doc/readme.txt)).

We first downloaded the station list of Tanzania (from [here](https://www.ncei.noaa.gov/maps/hourly/)), excluded the station without recent updates, and queried the records from their server. 

```{r}
# Clean the list of stations
stations <- read.csv("data/weather/stations.csv", stringsAsFactors = FALSE)
stations <- stations %>% 
    mutate(BEGIN_DATE = as.Date(BEGIN_DATE, format="%Y-%m-%d"),
           END_DATE = as.Date(END_DATE, format="%Y-%m-%d"))
stations <- stations %>% 
    filter(END_DATE > as.Date("2018-01-01", format="%Y-%m-%d"))

# Download the records
years <- seq(2011, 2022, 1)
url_base <- "https://www.ncei.noaa.gov/data/global-summary-of-the-day/access"

## First, check the data availability for every year
avals <- sapply(1:nrow(stations), function(n){
    station <- stations %>% slice(n)
    urls <- file.path(url_base, years, paste0(station$STATION_ID, ".csv"))
    all(sapply(urls, url.exists))
})
stations <- stations[avals, ]

## Get the station numbers
inds <- stations$STATION_ID

## Gather records
records <- do.call(rbind, lapply(inds, function(ind) {
    do.call(rbind, lapply(years, function(year){
        url <- file.path(url_base, year, paste0(ind, ".csv"))
        read.csv(url)
    }))
}))

# Summary the records
summary_records <- records %>% 
    mutate(year = lubridate::year(as.Date(DATE, format="%Y-%m-%d"))) %>% 
    group_by(STATION, year) %>% 
    summarise(n = n())

# Save out
write.csv(records, here("data/weather/GSOD_daily_records_2011_2022.csv"),
          row.names = FALSE)
write.csv(summary_records, 
          here("data/weather/GSOD_summary_daily_2011_2022.csv"),
          row.names = FALSE)
```


#### Make catalogs

```{r}
library(googledrive)
sf_use_s2(FALSE)

# Worldcover
fnames <- list.files(here("data/landcover/worldcover"),
                     recursive = TRUE)
fnames <- file.path("data/landcover/worldcover", fnames)
worldcover_catalog <- do.call(rbind, lapply(fnames, function(fname){
    rst <- rast(fname)
    as.polygons(ext(rst), crs = crs(rst)) %>% 
        st_as_sf() %>%
        mutate(fname = fname)
})) %>% st_make_valid()
write_sf(
    worldcover_catalog, 
    file.path(data_dir, "landcover/worldcover_catalog.geojson"))

# ALOS DSM
## Download first
# drive_auth() # generate token
files <- drive_ls("reconcile", pattern = "elevation")
walk(1:nrow(files), function(n){
    drive_download(
        file = files[[n, "id"]], 
        path = file.path(data_dir, "elevation/alos_dsm", files[[n, "name"]]))
})

fnames <- list.files(here("data/elevation/alos_dsm"),
                     recursive = TRUE)
fnames <- file.path("data/elevation/alos_dsm", fnames)
dsm_catalog <- do.call(rbind, lapply(fnames, function(fname){
    rst <- rast(fname)
    as.polygons(ext(rst), crs = crs(rst)) %>% 
        st_as_sf() %>%
        mutate(fname = fname)
})) %>% st_make_valid()
write_sf(
    dsm_catalog, 
    file.path(data_dir, "elevation/alos_dsm_catalog.geojson"))
```



```{r}
source(here("scripts/query_dsm.R"))

# Get the bbox to query the data
dst_path <- "/Volumes/wildbeest/alos_dsm"
species_range <- st_bbox(c(
    st_as_sfc(st_bbox(mammals)), st_as_sfc(st_bbox(amphibians)), 
    st_as_sfc(st_bbox(birds)), st_as_sfc(st_bbox(reptiles))))
query_dsm(species_range, dst_path)

# Download Worldcover for the global land cover
```

Make savanna mask using Tropical savanna climate zone in KÃ¶ppen-Geiger climate classification. In a conservative way, we consider tree cover, shrubland and grassland as savanna in savanna climate zone.

```{r}
savanna_fname <- file.path(data_dir, "climate/savanna_zone.tif")
savanna <- rast(file.path(data_dir, "climate/Beck_KG_V1_present_0p0083.tif"))
savanna <- savanna == 3
writeRaster(savanna, fname)
```

#### Refine mammals

Because the habitat classification system is different from land cover mapping system, it is impossible to match them perfectly. We mainly consider the level-1 habitat: Forest, Savanna, Shrubland, Grassland, Wetlands, Artificial/Terrestrial, Desert, Artificial/Aquatic.

```{r}
sf_use_s2(FALSE)
dsm_fname <- file.path(data_dir, "elevation/elevation.tif")
lc_fname <- file.path(data_dir, "landcover/landcover.tif")

# Make the search table for land cover
lc_table <- data.frame(
    code = c(1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100),
    name = c("Savanna", "Forest", "Shrubland", "Grassland", "Cropland",
             "Built-up", "Bare/sparse vegetation", "Snow and Ice",
             "Permanent water bodies", "Herbaceous wetland", 
             "Mangroves", "Moss and lichen"),
    Habitat = c("Savanna", "Forest", "Shrubland", "Grassland", "Cropland",
                "Built-up", "Dessert", "Snow and Ice", 
                "Permanent water bodies", "Wetlands (inland)",
                "Mangroves", "Moss and lichen"))

# Read the raw table
habitat_mammals <- do.call(
    rbind, lapply(mammals_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(!(Season == "Passage" & Suitability == "Marginal")) %>% 
    filter(!Habitat %in% c("Caves", "Root", "Marine"))

# Artificial/Aquatic mainly wetland as classified in the maps
habitat_mammals[
    habitat_mammals$Habitat %in% 
        c("Artificial/Aquatic"), "Habitat"] <- "Wetlands (inland)"

# Split Mangroves from forest
habitat_mammals[str_detect(habitat_mammals$Sub_habitat, "Mangrove"), 
                "Habitat"] <- "Mangroves"

# Split Artificial/Terrestrial into level-1 classes.
habitat_mammals[
    habitat_mammals$Sub_habitat %in% 
        c("Arable Land", "Plantations"), "Habitat"] <- "Cropland"
habitat_mammals[
    habitat_mammals$Sub_habitat %in% 
        c("Rural Gardens", "Pastureland"), "Habitat"] <- "Grassland"
habitat_mammals[
    habitat_mammals$Sub_habitat %in% 
        c("Subtropical/Tropical Heavily Degraded Former Forest"), 
    "Habitat"] <- "Forest"
habitat_mammals[
    habitat_mammals$Sub_habitat %in% 
        c("Urban Areas"), "Habitat"] <- "Built-up"

# Read elevation limits
ele_limits_mammals <- do.call(
    rbind, lapply(mammals_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)})) %>% 
    mutate(min_elevation = as.numeric(gsub(",", "", min_elevation)),
           max_elevation = as.numeric(gsub(",", "", max_elevation))) %>% 
    mutate(min_elevation = ifelse(is.na(min_elevation), -Inf, min_elevation),
           max_elevation = ifelse(is.na(max_elevation), Inf, max_elevation))

# Refine the range maps
mammal_map_refined <- do.call(
    rbind, lapply(1:nrow(mammals), function(n){
    # Read range
    this_mammal <- mammals[n, ] %>% st_make_valid()
    message(sprintf("No.%s: %s", n, this_mammal$sci_name))
    
    # Habitat and elevation limits
    this_habitat <- habitat_mammals %>% 
        filter(species == this_mammal$sci_name) %>% 
        left_join(lc_table, by = "Habitat")
    this_ele_limits <- ele_limits_mammals %>% 
        filter(species == this_mammal$sci_name)
    
    # Get land cover types
    landcover <- rast(lc_fname) %>% crop(this_mammal %>% st_buffer(1))
    
    # Check if savanna is evolved
    if ("Savanna" %in% this_habitat$Habitat) {
        savanna <- rast(savanna_fname) %>% 
            crop(this_mammal %>% st_buffer(1)) %>% 
            resample(landcover, method = "near")
        landcover[savanna == 1 & landcover %in% c(10, 20, 30)] <- 1
    }
    
    # Select habitats
    if (length(unique(this_habitat$code)) > 0){
        landcover <- landcover %in% unique(this_habitat$code)}
    
    # Read and set layers
    dsm <- rast(dsm_fname) %>% crop(this_mammal %>% st_buffer(1))
    dsm <- (dsm >= this_ele_limits$min_elevation) & 
        (dsm <= this_ele_limits$max_elevation)
    # Sum the mask
    msk <- dsm & landcover
    
    # Return a raster
    gmt <- as.polygons(rasterize(this_mammal, msk) * msk) %>% 
        st_as_sf()
    if (nrow(gmt) != 0) {
        gmt <- gmt %>% filter(layer == 1)
        if (nrow(gmt) != 0) {
            cbind(this_mammal %>% st_drop_geometry(), 
                  gmt %>% st_simplify() %>% select(-layer))
        }else{
            st_sf(cbind(this_mammal %>% st_drop_geometry(), 
                        geometry = st_sfc(st_multipolygon())))
        }
    }else{
        st_sf(cbind(this_mammal %>% st_drop_geometry(), 
                        geometry = st_sfc(st_multipolygon())))
    }
}))
```

#### Refine amphibians

```{r}
# Read the raw table
habitat_amphibians <- do.call(
    rbind, lapply(amphibians_info, function(x) {
        x$habitats %>% mutate(species = x$scientific_name)})) %>% 
    filter(!(Season == "Passage" & Suitability == "Marginal")) %>% 
    filter(!Habitat %in% c("Caves", "Root", "Marine"))

# Remove waterbodies
habitat_amphibians <- habitat_amphibians %>% 
    filter(!str_detect(
        Sub_habitat, "Ponds|Canals|Channels|Water|Excavations|Hydrological"))

# Artificial/Aquatic mainly wetland as classified in the maps
habitat_amphibians[
    habitat_amphibians$Habitat %in% 
        c("Artificial/Aquatic"), "Habitat"] <- "Wetlands (inland)"

# Split Mangroves from forest
habitat_amphibians[str_detect(habitat_amphibians$Sub_habitat, "Mangrove"), 
                "Habitat"] <- "Mangroves"

# Split Artificial/Terrestrial into level-1 classes.
habitat_amphibians[
    habitat_amphibians$Sub_habitat %in% 
        c("Arable Land", "Plantations"), "Habitat"] <- "Cropland"
habitat_amphibians[
    habitat_amphibians$Sub_habitat %in% 
        c("Rural Gardens", "Pastureland"), "Habitat"] <- "Grassland"
habitat_amphibians[
    habitat_amphibians$Sub_habitat %in% 
        c("Subtropical/Tropical Heavily Degraded Former Forest"), 
    "Habitat"] <- "Forest"
habitat_amphibians[
    habitat_amphibians$Sub_habitat %in% 
        c("Urban Areas"), "Habitat"] <- "Built-up"

# Read elevation limits
ele_limits_amphibians <- do.call(
    rbind, lapply(amphibians_info, function(x) {
        data.frame(min_elevation = x$lower_elevation,
                   max_elevation = x$upper_elevation,
                   species = x$scientific_name)})) %>% 
    mutate(min_elevation = as.numeric(gsub(",", "", min_elevation)),
           max_elevation = as.numeric(gsub(",", "", max_elevation))) %>% 
    mutate(min_elevation = ifelse(is.na(min_elevation), -Inf, min_elevation),
           max_elevation = ifelse(is.na(max_elevation), Inf, max_elevation))

# Refine the range maps
amphibian_map_refined <- do.call(rbind, mclapply(1:nrow(amphibians), function(n){
    # Read range
    this_amphibian <- amphibians[n, ] %>% st_make_valid()
    message(sprintf("No.%s: %s", n, this_amphibian$sci_name))
    
    # Habitat and elevation limits
    this_habitat <- habitat_amphibians %>% 
        filter(species == this_amphibian$sci_name) %>% 
        left_join(lc_table, by = "Habitat")
    this_ele_limits <- ele_limits_amphibians %>% 
        filter(species == this_amphibian$sci_name)
    
    # Get land cover types
    landcover <- rast(lc_fname) %>% crop(this_amphibian %>% st_buffer(1))
    
    # Check if savanna is evolved
    if ("Savanna" %in% this_habitat$Habitat) {
        savanna <- rast(savanna_fname) %>% 
            crop(this_amphibian %>% st_buffer(1)) %>% 
            resample(landcover, method = "near")
        landcover[savanna == 1 & landcover %in% c(10, 20, 30)] <- 1
    }
    
    # Select habitats
    if (length(unique(this_habitat$code)) > 0){
        landcover <- landcover %in% unique(this_habitat$code)}
    
    # Read and set layers
    dsm <- rast(dsm_fname) %>% crop(this_amphibian %>% st_buffer(1))
    dsm <- (dsm >= this_ele_limits$min_elevation) & 
        (dsm <= this_ele_limits$max_elevation)
    # Sum the mask
    msk <- dsm & landcover
    
    # Return a raster
    gmt <- as.polygons(rasterize(this_amphibian, msk) * msk) %>% 
        st_as_sf()
    if (nrow(gmt) != 0) {
        gmt <- gmt %>% filter(layer == 1)
        if (nrow(gmt) != 0) {
            cbind(this_amphibian %>% st_drop_geometry(), 
                  gmt %>% st_simplify() %>% select(-layer))
        }else{
            st_sf(cbind(this_amphibian %>% st_drop_geometry(), 
                        geometry = st_sfc(st_multipolygon())))
        }
    }else{
        st_sf(cbind(this_amphibian %>% st_drop_geometry(), 
                        geometry = st_sfc(st_multipolygon())))
    }
}, mc.cores = 5))
```
